<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Oof by danwguy</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Oof</h1>
        <h2>A PHP framework that strives to make programming very complex applications a breeze.</h2>

        <section id="downloads">
          <a href="https://github.com/danwguy/OOF/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/danwguy/OOF/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/danwguy/OOF" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="welcome-to-oof" class="anchor" href="#welcome-to-oof"><span class="octicon octicon-link"></span></a>Welcome to OOF.</h3>

<p>This framework is built very much like CodeIgniter as far as it is very lightweight and does not force you into a certain coding style. The Similarities don't go much further though, this framework is centered around flexibility, scalability, and pure ease of use. I tried to make it to where every level of developer can pick it up and within a couple minutes build a webpage. The syntax is super simple and you should be up and running building extremely complex relationships with no effort at all. The best part is, it allows you to either, toss a couple controllers, models, and view pages together and have a functional running website, or seriously dig deep and customize every single aspect of your application.</p>

<p>OOF is built around the MVC architecture so if you aren't familiar with that, you might want to study up on that a bit but the simple rundown is, the url decides which controller to call based on the url, the controller interacts with the model to do db stuff, then calls the view page, and there you go... a webpage. Obviously that is the bare simple breakdown and this goes a little further than that. OOF really tries to lend itself to all different coding styles and not judge you at all. As long as you know how to work with objects you should be fine, that's pretty much all you'll be getting, objects. In OOF you are always dealing in objects, even on your view page, you will not be sifting through arrays or any of that nonsense, it's objects all the way!</p>

<p>There are many hooks throughout the entire framework so that if you really want to completely control the flow of data and logic, the hooks will give you that availability. Some of the most used are part of the TableObject class, the central class for dealing with anything in a database, regardless of the flavor. It is responsible for taking your logic, queries, and whatnot and handing you back pretty shiny PHP objects. A quick glance at some of the hooks you have available to you will show you that from the very instant an object is even thought about you have control by grabbing the before_construction hook and they continue all the way through object creation with things like, before_retrieval(), before_saving(), after_retrieval(), after_saving(), and so on all the way to the very end at after_construction(). So whether you just want to pop a couple controllers together and some view pages and say look a webpage, or if you want to dig deep, get your hands dirty and control every single piece of the building blocks, you can!</p>

<h3>
<a name="relational-objects" class="anchor" href="#relational-objects"><span class="octicon octicon-link"></span></a>Relational Objects</h3>

<p>OOF gives you complete control of how you want to handle relations between objects. I have tried to incorporate every style I could think of while building this framework. There is even a programming debut, as far as I know anyway, for handling relationships. Let's take a look at some of the options for handling relationships in OOF.
First there is the very traditional hasMany, hasOne, and hasManyAndBelongsToMany relationships...</p>

<pre><code>class Product extends Model {
    var $hasOne = array('Category' =&gt; 'Category');
    var $hasManyAndBelongsToMany = array('Tag' =&gt; 'Tag');
}
class Category extends Model {
        var $hasMany = array('Product' =&gt; 'Product');
        var $hasOne = array('Parent' =&gt; 'Category');

}
</code></pre>

<p>Then in your controller you would bring them together like this...</p>

<pre><code>function view() {
   $this-&gt;Category-&gt;id = 1;
   $this-&gt;Category-&gt;showHasOne();
   $this-&gt;Category-&gt;showHasMany();
   $this-&gt;Category-&gt;showHMABTM();
   $data = $this-&gt;Category-&gt;search();
   print_r($data);
}
</code></pre>

<p>Not bad, it's your typical relational model, personally I prefer this next method as I feel it gives better coding and database practices and is a lot easier to understand.<br>
Sample Database:
Table: car_lots</p>

<pre><code>  id  |  name  |  owner  |  address  |  phone_number
-----------------------------------------------------
  1   | Cheapy | Steven  | 15235 SW  | 15550128845
      |McLemon-| Wright  | Buckly Rd |
      |sellers |         |Beaverton  |
</code></pre>

<p>and the cars table</p>

<pre><code>  id  |  make  |  model  |  color  |  car_lots_id
---------------------------------------------------
  1   | Ford   |  F-150  |  Black  |  1
</code></pre>

<p>Essentially ensure that if a car belongs to a car lot it has a car_lot_id in it, makes sense. Now the Controller...</p>

<pre><code>public function view($id) {
    $car_lot = new CarLot($id); // that will get the info from the db and build the carlot obj
    $car_lot-&gt;cars = CarLot::get_related('Car');
}
</code></pre>

<p>Simple eh? as long as the table cars has a car_lot_id get_related is an automagic function that will build all your objects for you in one simple command. Much nicer, cleaner, and easier than all that hasMany stuff, at least I think anyway.
But wait, there is another option, and it is a doosey. So let's say we have the exact same structure as above, the car_lots table, and the cars table with the car_lot_id in it. If you have enabled the ARDO option in your site config, your coding life is extremely simple now.</p>

<pre><code>//remember, we have the exact same table structure as in the previous example
//Controller
public function view($id) {
    $car_lot = new CarLot($id);
}
</code></pre>

<p>Yep, that's it. In one line of code, and in one single database query you will be given the car lot object that was retrieved from the database, as well as any and all associated objects regardless of relationship. Meaning if car lot has a 1 =&gt; Many relationship with car, as it should, your CarLot-&gt;Car is an array of car objects that are associated with that car lot. Not only that, but if the Car has associated relationships, like Tire, each one of the Car objects, will have it's associated object too! All in one line of code and in one database query. I know that sounds ridiculous but it's true, and the only thing you need to do to ensure that works is in your models, grab the before_construction hook and tell it there's a relationship like this...</p>

<pre><code>class CarLot extends TableObject {

    public $id;
    public $name;
    public $owner;
    public $address;
    public $phone_number;
    public static $column_list = array('id', 'name', 'owner', 'address', 'phone_numer');

    public function before_construction() {
        $this-&gt;relates['CarLot'] = 'Car';
    }

    public static function get_table() {
        return 'car_lots';
    }
}
</code></pre>

<p>That is that. Quite literally that is all you need and the framework does the rest for you.</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Rather Drive Stick?</h3>

<p>If you prefer to really dig in and control everything to give yourself more control over the objects you should probably get familiar with the hooks. In addition to the standard typical hooks that frameworks have; pre_system, cache_override, pre_controller, post_controller_construct, post_controller, display_override, and post_system. There are an abundance of system hooks as well so you can control the construction of your objects. Here's a quick rundown of the hooks available to you in OOF:<br></p>

<ul>
<li>before_construction()
<ul>
<li>A hook designed to allow you to run custom logic on objects at the start of __construct() before the OOF logic happens or anything else</li>
</ul>
</li>
<li>after_construction()
<ul><li>This is run after the object is constructed, either from the database, from the array of info passed to it, or the empty object returned from a blank new call</li></ul>
</li>
<li>before_creation()
<ul><li>This is run before the object is created when using the create() method. The create method is a magic static method that you pass an array of information to and it will construct the object, as well as save the information to the database.</li></ul>
</li>
<li>after_creation()
<ul><li>Run after the object is created and saved to the database when using the create() magic static method</li></ul>
</li>
<li>before_retrieval()
<ul><li>Run at the very start of the retrieve method that gets the information from the database when constructing an object.</li></ul>
</li>
<li>after_retrieval()
<ul><li>Run after the object is retrieved from the database and built.</li></ul>
</li>
<li>before_saving()
<ul><li>Run ar the start of save() whether called directly or with the static create method.</li></ul>
</li>
<li>after_saving()
<ul><li>Run after the object is saved to the database but before return of the method</li></ul>
</li>
<li>before_deletion()
<ul><li>Run at the beginning of the delete method. There are special methods that will not delete the information from the database, but rather mark it for deletion, this method is run at that time as well</li></ul>
</li>
<li>after_deletion()
<ul><li>Run at the end of the delete method and all methods that mark for deletion, but before the function returns</li></ul>
</li>
</ul><p>That is just a simple quick rundown of some of the hooks built into the framework to give you complete control over your application. For more information on these and more hooks in the system please refer to the documentation.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Created by Robert Mason (<a href="https://github.com/danwguy" class="user-mention">@danwguy</a>). Many many ideas were used from CodeIgniter, they have a great base so thank them for that. Please feel free to contribute to this project, I am really looking forward to community feedback and contribution. I think with this base and the brains of the many many genius developers out there this can really become something extremely powerful. I am always looking for a hand on the helper classes, speed improvements, and better cache solutions.</p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>If you have any questions or comments feel free to send me a message <a href="https://github.com/danwguy" class="user-mention">@danwguy</a>. Please realize this is not a complete project ready to run yet, it is still in development. It is ready to run some basic sites, but there is still work needing to be done before it can handle e-commerce sites.
Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages">http://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and weâ€™ll help you sort it out.</p>
      </section>
    </div>

    
  </body>
</html>